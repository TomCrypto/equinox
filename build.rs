#![allow(clippy::too_many_arguments)]

use crypto::rc4::Rc4;
use crypto::symmetriccipher::SynchronousStreamCipher;
use regex::Regex;
use std::env::var_os;
use std::ffi::OsStr;
use std::fmt::Write;
use std::fs::{read_dir, read_to_string, write};
use std::io::{ErrorKind, Result};
use std::path::{Path, PathBuf};

fn main() {
    if let Err(err) = preprocess_shaders("src/shader", "glsl", "include") {
        panic!("error: failed to preprocess GLSL shader files: {}", err);
    }
}

#[derive(Debug, Default)]
struct ShaderMetadata {
    headers: Vec<String>,
    defines: Vec<String>,
    uniform_blocks: Vec<String>,
    texture_units: Vec<String>,
}

fn preprocess_shaders(dir: &str, ext: &str, include_path: &str) -> Result<()> {
    let mut generated_file = String::from("/* autogenerated, do not edit */");

    writeln!(
        generated_file,
        r#"
    #[derive(Debug)]
    pub struct ShaderInfo {{
        pub code: &'static [u8],
        pub headers: &'static [&'static str],
        pub defines: &'static [&'static str],
        pub uniform_blocks: &'static [&'static str],
        pub texture_units: &'static [&'static str]
    }}
    "#
    )
    .unwrap();

    for entry in read_dir(dir)? {
        let entry = entry?;

        if !entry.metadata()?.is_file() {
            continue;
        }

        let path = entry.path();

        if path.extension() == Some(&OsStr::new(ext)) {
            let metadata = preprocess_glsl_shader(path, include_path)?;
            let path = PathBuf::from(entry.file_name());

            let mut name = path.file_stem().unwrap().to_str().unwrap().to_owned();
            name.make_ascii_uppercase(); // try to follow Rust's style conventions

            writeln!(
                generated_file,
                "\n/// GLSL source for the `{}` shader.",
                path.display(),
            )
            .unwrap();

            let out_dir: PathBuf = var_os("OUT_DIR").unwrap().into();
            let shader = read_to_string(out_dir.join(path.file_name().unwrap()))?;

            let mut rc4 =
                Rc4::new(b"\x80\x33\x5d\x92\x96\x5f\xbd\x83\x63\x5f\xbd\x86\x54\x7f\xf9\x3c");

            let mut shader_bytes = vec![0; shader.as_bytes().len()];

            rc4.process(shader.as_bytes(), &mut shader_bytes);

            writeln!(
                generated_file,
                r#"pub const {}: ShaderInfo = ShaderInfo {{
                code: &{:?},
                headers: &{:?},
                defines: &{:?},
                uniform_blocks: &{:?},
                texture_units: &{:?},
            }};"#,
                name,
                shader_bytes,
                metadata.headers,
                metadata.defines,
                metadata.uniform_blocks,
                metadata.texture_units
            )
            .unwrap();
        }
    }

    let out_dir: PathBuf = var_os("OUT_DIR").unwrap().into();
    write(out_dir.join("glsl_shaders.rs"), &generated_file)?;

    Ok(())
}

fn preprocess_glsl_shader(path: PathBuf, include_path: &str) -> Result<ShaderMetadata> {
    println!("cargo:rerun-if-changed={}", path.display());
    let (mut expanding, mut processed) = (vec![], vec![]);

    let mut metadata = ShaderMetadata::default();

    let shader = preprocess(
        &read_to_string(&path)?,
        path.file_name().unwrap().to_str().unwrap(),
        path.parent().unwrap(),
        &PathBuf::from(include_path),
        &mut expanding,
        &mut processed,
        &mut metadata,
        false,
    )?;

    gather_metadata(&shader, &mut metadata);

    let out_dir: PathBuf = var_os("OUT_DIR").unwrap().into();
    write(out_dir.join(path.file_name().unwrap()), &shader)?;

    Ok(metadata)
}

fn preprocess(
    text: &str,
    name: &str,
    relative_path: &Path,
    includes_path: &Path,
    expanding: &mut Vec<String>,
    processed: &mut Vec<String>,
    metadata: &mut ShaderMetadata,
    placeholder: bool,
) -> Result<String> {
    let include_pattern = Regex::new(r#"^#include +<([[:graph:]]+)>$"#).unwrap();

    println!(
        "cargo:rerun-if-changed={}",
        relative_path.join(name).display()
    );

    expanding.push(name.to_owned());

    let mut shader = format!("// __POS__ {}:1\n", name);

    if placeholder {
        shader += text;
    }

    for (index, line) in text.lines().enumerate() {
        if placeholder {
            break;
        }

        if let Some(captures) = include_pattern.captures(line) {
            let header = captures.get(1).unwrap().as_str();

            if vec_contains(processed, &header) {
                writeln!(shader).unwrap();
                continue; // already seen
            }

            if vec_contains(expanding, &header) {
                panic!("circular inclusion of GLSL header: {}", header);
            }

            // If we don't find the file, simply leave the #include in there to be populated
            // dynamically by the renderer. The file/line marker comments are still added in
            // which allows compilation errors inside dynamic includes to still be reported.

            let result = read_to_string(&relative_path.join(includes_path.join(&header)));

            let (text, placeholder) = match result {
                Err(err) if err.kind() == ErrorKind::NotFound => {
                    metadata.headers.push(header.to_owned());
                    (format!("#include <{}>", header), true)
                }
                result => (result?, false),
            };

            let included = preprocess(
                &text,
                &header,
                relative_path,
                includes_path,
                expanding,
                processed,
                metadata,
                placeholder,
            )?;

            writeln!(shader, "{}\n// __POS__ {}:{}", included, name, index + 2).unwrap();
        } else {
            writeln!(shader, "{}", line).unwrap();
        }
    }

    processed.push(name.to_owned());

    Ok(shader)
}

fn gather_metadata(text: &str, metadata: &mut ShaderMetadata) {
    let define_pattern = Regex::new(r#"^// requires-define ([[:graph:]]+)"#).unwrap();
    let uniform_block_pattern =
        Regex::new(r#"^layout *\(std140\) +uniform +([[:graph:]]+) *\{$"#).unwrap();
    let texture_unit_pattern =
        Regex::new(r#"^uniform +[ui]?sampler2D +([[:graph:]]+) *;$"#).unwrap();

    for line in text.lines() {
        if let Some(captures) = define_pattern.captures(line) {
            metadata
                .defines
                .push(captures.get(1).unwrap().as_str().to_owned());
        }

        if let Some(captures) = uniform_block_pattern.captures(line) {
            metadata
                .uniform_blocks
                .push(captures.get(1).unwrap().as_str().to_owned());
        }

        if let Some(captures) = texture_unit_pattern.captures(line) {
            metadata
                .texture_units
                .push(captures.get(1).unwrap().as_str().to_owned());
        }
    }
}

fn vec_contains(vec: &[String], item: &str) -> bool {
    vec.iter().any(|x| x == item) // see issue #42671
}
