//! The Equinox stochastic photon mapper, see the README for more information.

#![allow(clippy::module_inception)]
#![forbid(dead_code, unsafe_code)]

mod device {
    pub mod camera;
    pub mod device;
    pub mod display;
    pub mod environment;
    pub mod geometry;
    pub mod instance;
    pub mod integrator;
    pub mod lens_flare;
    pub mod material;
    pub mod raster;
}

mod engine {
    pub mod framebuffer;
    pub mod shader;
    pub mod texture;
    pub mod uniform_buffer;
    pub mod vertex_array;
}

mod scene {
    pub mod aperture;
    pub mod bounding_box;
    pub mod camera;
    pub mod dirty;
    pub mod display;
    pub mod environment;
    pub mod geometry;
    pub mod instance;
    pub mod integrator;
    pub mod material;
    pub mod raster;
    pub mod scene;
}

pub use device::{
    camera::*, device::*, display::*, environment::*, geometry::*, instance::*, integrator::*,
    lens_flare::*, material::*, raster::*,
};
pub use engine::{framebuffer::*, shader::*, texture::*, uniform_buffer::*, vertex_array::*};
pub use scene::{
    aperture::*, bounding_box::*, camera::*, dirty::*, display::*, environment::*, geometry::*,
    instance::*, integrator::*, material::*, raster::*, scene::*,
};

/// WebGL shaders from the `shader` directory.
///
/// This module is autogenerated by the crate build script which will handle all
/// GLSL preprocessing such as expanding #includes and adding file/line markers.
pub mod shader {
    include!(concat!(env!("OUT_DIR"), "/glsl_shaders.rs"));
}

use cgmath::{prelude::*, Basis3, Vector3};
use js_sys::{Array, Error};
use maplit::btreemap;
use serde::{de::DeserializeOwned, Serialize};
use wasm_bindgen::prelude::*;
use web_sys::WebGl2RenderingContext;

/// WASM binding for a scene.
#[wasm_bindgen]
#[derive(Debug, Default)]
pub struct WebScene {
    scene: Scene,
}

#[wasm_bindgen]
impl WebScene {
    /// Creates a new empty scene.
    #[wasm_bindgen(constructor)]
    pub fn new() -> WebScene {
        Self::default()
    }

    pub fn json(&self) -> Result<JsValue, JsValue> {
        as_json(&self.scene)
    }

    pub fn raster_width(&self) -> u32 {
        self.scene.raster.width
    }

    pub fn raster_height(&self) -> u32 {
        self.scene.raster.height
    }

    /// Reconfigures the scene using the provided scene JSON data.
    ///
    /// This method will attempt to dirty the least amount of scene data
    /// possible, so it won't necessarily always dirty the entire scene.
    pub fn set_json(&mut self, json: &JsValue) -> Result<(), JsValue> {
        let mut temporary: Scene = from_json(json)?;

        std::mem::swap(&mut self.scene.assets, &mut temporary.assets);

        if let Err(error) = temporary.validate() {
            std::mem::swap(&mut self.scene.assets, &mut temporary.assets);
            return Err(error.into()); // put the assets back on the scene
        }

        self.scene.patch_from_other(temporary);

        Ok(())
    }

    /// Returns the list of all assets in the scene as a JS string array.
    pub fn assets(&self) -> Array {
        self.scene.assets.keys().map(JsValue::from).collect()
    }

    pub fn set_raster_dimensions(&mut self, width: u32, height: u32) {
        if self.scene.raster.width != width {
            self.scene.raster.width = width;
        }

        if self.scene.raster.height != height {
            self.scene.raster.height = height;
        }
    }

    pub fn insert_asset(&mut self, name: &str, data: &[u8]) {
        self.scene.assets.insert(name.to_owned(), data.to_vec());
    }

    pub fn remove_asset(&mut self, name: &str) {
        self.scene.assets.remove(name);
    }

    pub fn set_environment_rotation(&mut self, new_rotation: f32) {
        Dirty::modify(&mut self.scene.environment, |environment| {
            if let Environment::Map { rotation, .. } = environment {
                *rotation = new_rotation;
            }
        });
    }

    pub fn set_envmap(&mut self, name: &str) {
        Dirty::modify(&mut self.scene.environment_map, |environment_map| {
            *environment_map = Some(name.to_owned());
        });

        Dirty::modify(&mut self.scene.environment, |environment| {
            if let Environment::Map { .. } = environment {
                // do nothing; we're already in map mode
            } else {
                *environment = Environment::Map {
                    tint: [1.0; 3],
                    rotation: 0.0,
                };
            }
        });
    }

    /// Applies a camera-space translation to the camera position.
    pub fn move_camera(&mut self, dx: f32, dy: f32, dz: f32) {
        let mut direction: Vector3<f32> = self.scene.camera.direction.into();
        let mut up_vector: Vector3<f32> = self.scene.camera.up_vector.into();

        direction = direction.normalize();
        up_vector = up_vector.normalize();

        let xfm = Basis3::look_at(direction, up_vector).invert();
        let rotated_dir = xfm.rotate_vector([dx, dy, dz].into());

        self.scene.camera.position[0] += rotated_dir[0];
        self.scene.camera.position[1] += rotated_dir[1];
        self.scene.camera.position[2] += rotated_dir[2];
    }

    pub fn set_camera_direction(&mut self, x: f32, y: f32, z: f32) {
        if self.scene.camera.direction != [x, y, z] {
            self.scene.camera.direction = [x, y, z];
        }
    }

    /// Sets the scene to a default scene.
    pub fn set_default_scene(&mut self) {
        self.scene = Scene::default();

        // Set up an "interesting" default scene below. We do this here because we
        // have proper types whereas doing it in the front-end would require JSON.

        self.scene.geometry_list.insert(
            "ground".to_owned(),
            Geometry::Cuboid {
                dimensions: [
                    Parameter::Constant(3.0),
                    Parameter::Constant(0.01),
                    Parameter::Constant(3.0),
                ],
            },
        );

        self.scene.geometry_list.insert(
            "sphere".to_owned(),
            Geometry::Translate {
                translation: [
                    Parameter::Symbolic("x".to_owned()),
                    Parameter::Symbolic("y".to_owned()),
                    Parameter::Symbolic("z".to_owned()),
                ],
                f: Box::new(Geometry::Sphere {
                    radius: Parameter::Constant(0.799),
                }),
            },
        );

        self.scene.material_list.insert(
            "phong".to_owned(),
            Material::Phong {
                albedo: [0.9, 0.9, 0.9],
                shininess: 20.0,
            },
        );

        self.scene.material_list.insert(
            "lambertian".to_owned(),
            Material::Lambertian {
                albedo: [0.9, 0.6, 0.2],
            },
        );

        self.scene.material_list.insert(
            "diffuse1".to_owned(),
            Material::OrenNayar {
                albedo: [0.1, 0.7, 0.7],
                roughness: 1.0,
            },
        );

        self.scene.material_list.insert(
            "phong2".to_owned(),
            Material::Phong {
                albedo: [0.3, 0.9, 0.7],
                shininess: 700.0,
            },
        );

        self.scene.material_list.insert(
            "glass1".to_owned(),
            Material::Dielectric {
                internal_refractive_index: 2.2,
                external_refractive_index: 1.0,
                internal_extinction_coefficient: [1.0, 1.0, 1.0],
                external_extinction_coefficient: [0.0, 0.0, 0.0],
                base_color: [0.560, 0.570, 0.580],
            },
        );

        self.scene.material_list.insert(
            "glass2".to_owned(),
            Material::IdealRefraction {
                transmittance: [0.0, 1.0, 0.0],
                refractive_index: 1.3,
            },
        );

        self.scene.instance_list.insert(
            "ground".to_owned(),
            Instance {
                geometry: "ground".to_owned(),
                material: "lambertian".to_owned(),
                parameters: btreemap! {},
                photon_receiver: true,
                sample_explicit: true,
                visible: true,
            },
        );

        self.scene.instance_list.insert("glass-sphere".to_owned(), Instance {
            geometry: "sphere".to_owned(),
            material: "glass2".to_owned(),
            parameters: btreemap! {"x".to_owned() => 0.0, "y".to_owned() => 0.81, "z".to_owned() => 0.0 },
            photon_receiver: true,
            sample_explicit: true,
            visible: true,
        });

        self.scene.instance_list.insert("diffuse-sphere".to_owned(), Instance {
            geometry: "sphere".to_owned(),
            material: "diffuse1".to_owned(),
            parameters: btreemap! { "x".to_owned() => -2.0, "y".to_owned() => 0.81, "z".to_owned() => 0.0 },
            photon_receiver: true,
            sample_explicit: true,
            visible: true,
        });

        self.scene.camera.position[0] = 0.0;
        self.scene.camera.position[1] = 7.5;
        self.scene.camera.position[2] = 14.2;

        self.scene.camera.direction[0] = 0.0;
        self.scene.camera.direction[1] = -0.5;
        self.scene.camera.direction[2] = -0.85;

        self.scene.camera.aperture = ApertureShape::Circle { radius: 0.0 };

        self.scene.camera.focal_distance = 15.44;
    }
}

fn as_json<T: Serialize>(value: &T) -> Result<JsValue, JsValue> {
    Ok(JsValue::from_serde(value).map_err(|e| Error::new(&e.to_string()))?)
}

fn from_json<T: DeserializeOwned>(json: &JsValue) -> Result<T, JsValue> {
    Ok(json.into_serde().map_err(|e| Error::new(&e.to_string()))?)
}

/// WASM binding for a device.
#[wasm_bindgen]
#[derive(Debug)]
pub struct WebDevice {
    device: Device,
}

#[wasm_bindgen]
impl WebDevice {
    #[wasm_bindgen(constructor)]
    pub fn new(context: &WebGl2RenderingContext) -> Result<WebDevice, JsValue> {
        Ok(Self {
            device: Device::new(context)?,
        })
    }

    /// Updates the device with a scene, returning true if an update occurred.
    pub fn update(&mut self, scene: &mut WebScene) -> Result<bool, JsValue> {
        Ok(self.device.update(&mut scene.scene)?)
    }

    /// Refines the render using the integrator.
    pub fn refine(&mut self) -> Result<(), JsValue> {
        Ok(self.device.refine()?)
    }

    /// Renders the current integrator data.
    pub fn render(&mut self) -> Result<(), JsValue> {
        Ok(self.device.render()?)
    }

    /// Returns the number of photons traced by the SPPM integrator.
    pub fn sppm_photons(&self) -> f64 {
        self.device.state.photon_count as f64
    }

    /// Returns the number of passes performed by the SPPM integrator.
    pub fn sppm_passes(&self) -> u32 {
        self.device.state.current_pass
    }

    /// Indicates to the device that its WebGL context has been lost.
    pub fn context_lost(&mut self) {
        self.device.context_lost();
    }
}

/// Returns a version string for the WASM module.
#[wasm_bindgen]
pub fn version() -> String {
    concat!("Equinox v", env!("CARGO_PKG_VERSION"), " (WebGL2)").to_owned()
}

/// Configures browser logging functionality.
///
/// This initialization function is always safe to call more than once, so it
/// can be called safely every time the UI is hot-reloaded without panicking.
#[wasm_bindgen]
pub fn initialize_logging() {
    console_error_panic_hook::set_once();
    let _ = console_log::init();
}
