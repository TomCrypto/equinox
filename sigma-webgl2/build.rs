use lazy_static::lazy_static;
use regex::Regex;
use std::env::var_os;
use std::ffi::OsStr;
use std::fmt::Write;
use std::fs::{read_dir, read_to_string, write};
use std::io::Result;
use std::path::{Path, PathBuf};

fn vec_contains(vec: &Vec<String>, item: &str) -> bool {
    vec.iter().any(|x| x == item) // see issue #42671
}

lazy_static! {
    static ref REGEX: Regex =
        Regex::new(r#"^\s*#\s*include\s+(?:<([[:graph:]]*)>)|(?:"([[:graph:]]*)")\s*$"#).unwrap();
}

fn preprocess(
    text: &str,
    name: &str,
    relative_path: &Path,
    includes_path: &Path,
    expanding: &mut Vec<String>,
    processed: &mut Vec<String>,
) -> Result<String> {
    let mut shader = format!("// __POS__ {}:0\n", name);
    expanding.push(name.to_owned()); // now inside here

    for (index, line) in text.lines().enumerate() {
        if let Some(captures) = REGEX.captures(line) {
            let capture = captures.get(1).or(captures.get(2)).unwrap();
            let include = capture.as_str(); // captures either <> or ""

            if vec_contains(processed, &include) {
                continue; // assume #pragma once
            }

            if vec_contains(expanding, &include) {
                panic!("circular #include involving {} detected", capture.as_str());
            }

            let included = preprocess(
                &read_to_string(&relative_path.join(includes_path.join(&include)))?,
                &include,
                relative_path,
                includes_path,
                expanding,
                processed,
            )?;

            write!(shader, "{}\n// __POS__ {}:{}\n", included, name, index + 1).unwrap();
        } else {
            write!(shader, "{}\n", line).unwrap();
        }
    }

    processed.push(name.to_owned());

    Ok(shader)
}

fn preprocess_glsl_shader(path: PathBuf, include_path: &str) -> Result<()> {
    let (mut expanding, mut processed) = (vec![], vec![]);

    let shader = preprocess(
        &read_to_string(&path)?,
        path.file_name().unwrap().to_str().unwrap(),
        path.parent().unwrap(),
        &PathBuf::from(include_path),
        &mut expanding,
        &mut processed,
    )?;

    let out_dir: PathBuf = var_os("OUT_DIR").unwrap().into();
    write(out_dir.join(path.file_name().unwrap()), &shader)?;

    Ok(())
}

fn preprocess_shaders(dir: &str, ext: &str, include_path: &str) -> Result<()> {
    let mut text = String::from("/* autogenerated by build.rs, do not edit */");

    for entry in read_dir(dir)? {
        let entry = entry?;

        if !entry.metadata()?.is_file() {
            continue;
        }

        let path = entry.path();

        if path.extension() == Some(&OsStr::new(ext)) {
            preprocess_glsl_shader(path, include_path)?;
            let path = PathBuf::from(entry.file_name());

            let mut name = path.file_stem().unwrap().to_str().unwrap().to_owned();
            name.make_ascii_uppercase(); // try to follow Rust's style conventions

            write!(
                text,
                "\npub const {}: &str = include_str!(\"{}\");\n",
                name,
                path.display(),
            )
            .unwrap();
        }
    }

    let out_dir: PathBuf = var_os("OUT_DIR").unwrap().into();
    write(out_dir.join("processed_glsl_shaders.rs"), &text)?;

    Ok(())
}

fn main() {
    if let Err(err) = preprocess_shaders("src/shaders", "glsl", "include") {
        panic!("error: failed to preprocess GLSL shader files: {}", err);
    }
}
